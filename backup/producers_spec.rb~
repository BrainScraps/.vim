require 'spec_helper'

describe 'producers' do
  before(:all) do
    create_instances(4, :producer)
    create_instances(2, :api_key)
    @auth_header = {"HTTP_AUTHORIZATION" => "Token token=#{@api_key_1.access_token}", :referer => "http://localhost.com/"}
    @bad_header = {"HTTP_AUTHORIZATION" => "Token token=whatigotchugottogiveittoyomama", :referer => "http://haxxors.io"}
   end

  after(:all) do
    DatabaseCleaner.clean
  end

  describe 'POST /producers/' do
    it 'should create a new producer' do
      offer_id = @producer_1.offer.id
      post '/producers/', {name: "dad", description:"foo", offer_id: offer_id, uuid: random_uuid}, @auth_header
      expect(Producer.last.name).to eq "dad"
      expect(Producer.last.description).to eq "foo"
      expect(Offer.find(offer_id).producers).to include(Producer.last)
    end

    it 'should return a new producer object' do
      offer_id = @producer_1.offer.id
      post '/producers/', {name: "dad", description:"foo", offer_id: offer_id, uuid: random_uuid}, @auth_header
      expect(response.status).to eq 201
      expect(json["name"]).to eq "dad"
      expect(json["id"].class).to eq Fixnum
      expect(json["offer_id"]).to eq offer_id
    end

    it 'should default a new producer to the free offer' do
      Producer.destroy_all
      offer = create(:offer, {default: true})
      default_offer = Offer.where(default: true).first
      @rnd = random_uuid
      expect(Producer.count).to eq 0
      post '/producers/', {name: "what", description:"okay", uuid: @rnd}, @auth_header
      expect(response.status).to eq 201
      expect(Producer.count).to eq 1
      new_producer = Producer.where(id: json["id"]).first
      expect(new_producer).to be_an_instance_of(Producer)
      expect(new_producer.name).to eq "what"
      expect(new_producer.description).to eq "okay"
      expect(new_producer.offer).to eq default_offer
    end

    it 'should return an error when given an invalid offer id' do
      post '/producers', {name: "dad", description:"foo", offer_id: 12345621, uuid: random_uuid}, @auth_header
      expect(response.status).to eq 400
      expect(json['errors']).to include "Offer #12345621 does not exist"
    end

    it 'should reject a valid request if the api token is invalid' do
      Producer.destroy_all
      offer = create(:offer, {default: true})
      default_offer = Offer.where(default: true).first
      @rnd = random_uuid
      expect(Producer.count).to eq 0
      post '/producers/', {name: "what", description:"okay", uuid: @rnd}, @bad_header
      expect(response.status).to eq 401
      expect(Producer.count).to eq 0
    end
  end
  describe 'PATCH /producers/' do
    describe "valid" do
      
      it "should update a producer's name" do
        patch "/producers/#{@producer_1.uuid}", {name: "new name"}, @auth_header
        expect(response.status).to eq 200
        expect(json["name"]).to eq "new name"
      end

      it 'should update the description for a producer' do
        patch "/producers/#{@producer_1.uuid}", {description: "new desc"}, @auth_header
        expect(response.status).to eq 200
        expect(json["description"]).to eq "new desc"
      end

      it "should update a producer's UUID" do
        @rand = random_uuid
        patch "/producers/#{@producer_1.uuid}", {uuid: @rand}, @auth_header
        expect(response.status).to eq 200
        expect(json["uuid"]).to eq @rand
      end

      it 'should update a producer' do
        new_offer_id = Offer.where("id != ?", @producer_1.offer_id ).first.id
        patch "/producers/#{@producer_1.uuid}", {offer_id: new_offer_id}, @auth_header
        expect(response.status).to eq 200
        expect(json["offer_id"]).to eq new_offer_id
      end

      it 'should not save if offer id already exists for producer' do
        Transition.count.should eq 0
        expect(@producer_1.offer_id).to be_true
        patch "/producers/#{@producer_1.uuid}", {offer_id: @producer_1.offer_id}, @auth_header
        Transition.count.should eq 0
        expect(response.status).to eq 400
      end

      it 'should create a transition record if the offer_id is updated' do
        Transition.count.should eq 0
        patch "/producers/#{@producer_1.uuid}", {offer_id: Offer.where("id != ?", @producer_1.offer_id ).first.id}, @auth_header
        expect(response.status).to eq 200
        Transition.count.should eq 1
      end

      it 'should set the end_date based on the offer duration' do
        offer = Offer.where("id != ?", @producer_1.offer_id ).first
        Transition.count.should eq 0
        expect(offer.duration).to eq 30
        patch "/producers/#{@producer_1.uuid}", {offer_id: offer.id}, @auth_header
        expect(response.status).to eq 200
        Transition.count.should eq 1
        expect(Transition.last.end_date).to eq Date.today + offer.duration
      end

      it 'should set the end_date as nil based on the offer duration being 0' do
        Transition.count.should eq 0
        offer_no_duration = create(:offer, {duration: nil})
        expect(Offer.last.duration).to eq nil
        patch "/producers/#{@producer_3.uuid}", {offer_id: Offer.last.id}, @auth_header
        expect(response.status).to eq 200
        Transition.count.should eq 1
        expect(Transition.last.end_date).to eq nil
      end
    end

    describe "invalid" do
      it 'should return a 400 response' do
        patch "/producers/#{@producer_1.uuid}", {offer_id: "xyz"}, @auth_header
        expect(response.status).to eq 400
      end

      it 'should return a 401 if api token is invalid' do 
        patch "/producers/#{@producer_1.uuid}", {offer_id: "xyz"}, @bad_header
        expect(response.status).to eq 401  
      end
    end
  end

  describe 'GET /producers/' do
    it 'should return a response of producers' do
      get "/producers/"
      expect(response.status).to eq 200
      expect(json).to eq Producer.all.collect{|producer| {"id" => producer.id, "name" => producer.name, "description" => producer.description, "offer_id" =>  producer.offer_id}}
    end
  end

  describe 'GET /producers/[uuid]/' do
    it 'should return a 404 error and message if not found' do
      rnd = random_uuid
      get "/producers/#{rnd}"
      expect(response.status).to eq 404
      expect(response.body).to include "not found"
    end

    it 'should correctly identify all features the producer can access' do
      # store an array of features directly from the model
      features = @producer_1.features.map(&:id)
      get "/producers/#{@producer_1.uuid}"
      expect(json["enabled_features"].length).to eq features.length
      expect(json["enabled_features"]).to eq features
    end
  end

  describe 'GET /producers/[uuid]/permissions?feature_id=[:feature_id]' do
    it "should return a true value for a valid feature" do
      get "/producers/#{@producer_1.uuid}/permissions?feature_id=#{@producer_1.features.first.id}"
      expect(response.status).to eq 200
      expect(json["enabled"]).to eq 1
    end

    it "should return a boolean false for invalid param" do
      get "/producers/#{@producer_1.uuid}/permissions?feature_id=123"
      expect(response.status).to eq 200
      expect(JSON.parse(response.body)).to eq({"enabled" => 0})
    end

    it "should return a boolean false for invalid param" do
      get "/producers/#{@producer_1.uuid}/permissions?feature_id='xyz'"
      expect(response.status).to eq 200
      expect(json["enabled"]).to eq 0
    end
  end

  describe 'GET /producers/[uuid]/permissions' do
    it "should return a list of permissions for all features " do
      get "/producers/#{@producer_2.uuid}/permissions"
      expect(response.status).to eq 200
      expect(json.length).to eq Feature.all.length
    end

    it "should correctly identify enabled features" do
      get "/producers/#{@producer_2.uuid}/permissions"
      expect(response.status).to eq 200 
      json.each do |key, value|
        expect(value).to eq (@producer_2.has_feature?(key) == true ? 1 : 0)
      end
    end

    it "should handle an invalid producer id" do
      get "/producers/blahblah/permissions"
      expect(response.status).to eq 400
      expect(json["errors"]).to eq "Producer blahblah not found"
    end
  end
end
